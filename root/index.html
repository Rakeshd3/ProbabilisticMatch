
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entity Matching & Data Automation Project</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Rakesh Dash | Entity Matching Portfolio</a>
        </div>
    </nav>

    <div class="container mt-5">
        <section id="overview">
            <h2>Project Overview</h2>
            <p>This project automates entity name matching across multiple datasets, such as customer/vendor databases. It detects inconsistencies in names due to spelling mistakes, abbreviations, and inconsistent suffix usage. Once matched, it updates a Snowflake table with the best probable match and supporting metadata.</p>
        </section>

        <section id="problem-solved" class="mt-4">
            <h2>Problems Solved</h2>
            <ul>
                <li>Manually missed customers due to spelling inconsistencies.</li>
                <li>Manual reconciliation was time-consuming and error-prone.</li>
                <li>Duplicate or false entries affecting compliance reports (ESG).</li>
                <li>No centralized, automated way to store and track match results.</li>
            </ul>
        </section>

        <section id="pipeline-structure" class="mt-4">
            <h2>System Architecture & Workflow</h2>
            <p>The system is composed of the following layers:</p>
            <ol>
                <li><strong>Data Preprocessing:</strong> Input data is cleaned, normalized using regular expressions, and tokenized.</li>
                <li><strong>String Cleaning & NLP Layer:</strong> Abbreviation handling, stopword removal, and keyword boosting using domain-specific lexicons.</li>
                <li><strong>Matching Logic:</strong> Multiple fuzzy logic layers with scoring, thresholds, and keyword amplification to increase accuracy.</li>
                <li><strong>Result Categorization:</strong> Each match is tagged as Exact, Near, Probable, or Unmatched with human-readable justification.</li>
                <li><strong>Snowflake Integration:</strong> Matches are written back to Snowflake using merge-upsert logic.</li>
            </ol>
        </section>

        <section id="nlp-techniques" class="mt-4">
            <h2>Text Cleaning & NLP Techniques</h2>
            <ul>
                <li><strong>Regex Normalization:</strong> Removed special characters, legal suffixes (Ltd, Pvt, LLP, etc.), and common noise terms.</li>
                <li><strong>Token Sorting:</strong> Handled name order changes (e.g., "Tata Steel" vs "Steel Tata").</li>
                <li><strong>Domain Keyword Boosting:</strong> Keywords like "Steel", "Infra", "Agro" increase match score if present in both sides.</li>
                <li><strong>Stopword Removal:</strong> Optional filtering of business-irrelevant tokens using a curated list.</li>
            </ul>
        </section>

        <section id="code-examples" class="mt-4">
            <h2>Key Code Snippets</h2>
            <pre><code class="language-python">
# Normalization
name = name.lower().strip()
name = re.sub(r'[^\w\s]', '', name)
name = re.sub(r'\bltd\b|\blimited\b|\bpvt\b|\bprivate\b', '', name)
tokens = sorted(name.split())

# Domain-aware boost
boost = 1.2 if any(word in name for word in ['steel', 'agro']) else 1.0
score = base_score * boost

# Tiered result classification
if score == 100:
    level = "Exact Match"
elif score > 85:
    level = "Near Match"
elif score > 70:
    level = "Probable Match"
else:
    level = "Unmatched"
            </code></pre>
        </section>

        <section id="snowflake-integration" class="mt-4">
            <h2>Snowflake Update Logic</h2>
            <p>Snowflake is updated using MERGE statements to ensure idempotency and version-safe updates:</p>
            <pre><code class="language-sql">
MERGE INTO target_table AS T
USING staging_table AS S
ON T.id = S.id
WHEN MATCHED THEN UPDATE SET match_score = S.match_score
WHEN NOT MATCHED THEN INSERT (id, name, match_score)
VALUES (S.id, S.name, S.match_score);
            </code></pre>
        </section>

        <section id="sample-data" class="mt-4">
            <h2>Sample Files</h2>
            <p><a href="sample_input.csv" download>Download Sample Input</a></p>
            <p><a href="sample_output.csv" download>Download Sample Output</a></p>
        </section>

        <section id="contact" class="mt-4 mb-5">
            <h2>Contact</h2>
            <p><strong>Email:</strong> rdash6181@gmail.com</p>
            <p><a href="https://github.com/Rakeshd3" target="_blank">GitHub</a></p>
        </section>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
